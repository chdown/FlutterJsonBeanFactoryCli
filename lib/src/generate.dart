import 'dart:io';

import 'package:path/path.dart' as p;
import 'config.dart';
import 'log.dart';
import 'types.dart';

Future<bool> generateAll(Config cfg, List<EntitySource> entities) async {
  final startTime = DateTime.now();
  var changed = false;
  int filesGenerated = 0;

  // 1) json_field.dart
  final jf = File(p.join(cfg.genBaseDir.path, 'json_field.dart'));
  final jsonFieldContent = _jsonFieldTemplate();
  if (await _writeIfChanged(jf, jsonFieldContent, cfg)) {
    changed = true;
    filesGenerated++;
  }

  // 2) entity .g.dart files
  final expected = <String>{};
  // build class -> source path index for import resolution
  final classPathIndex = _buildClassPathIndex(entities);

  for (final e in entities) {
    final base = p.setExtension(p.basename(e.relativePathUnderLib), '.g.dart');
    expected.add(base);
    final out = File(p.join(cfg.projectPath, 'lib', cfg.genPath, base));
    final content = _renderEntity(cfg, e, classPathIndex);
    if (await _writeIfChanged(out, content, cfg)) {
      changed = true;
      filesGenerated++;
    }
  }

  // 3) json_convert_content.dart
  final jcc = File(p.join(cfg.genBaseDir.path, 'json_convert_content.dart'));
  final convertContent = _renderConvertContent(cfg, entities);
  if (await _writeIfChanged(jcc, convertContent, cfg)) {
    changed = true;
    filesGenerated++;
  }

  // 4) prune - 清理不再需要的 .g.dart 文件
  final genDir = Directory(p.join(cfg.projectPath, 'lib', cfg.genPath));
  if (await genDir.exists()) {
    await for (final f in genDir.list()) {
      if (f is File && f.path.endsWith('.g.dart')) {
        final name = p.basename(f.path);
        if (!expected.contains(name)) {
          try {
            await f.delete();
            logInfo('[rm] ${f.path}', cfg.logLevel);
            changed = true;
          } catch (e) {
            logWarn('[warn] failed to delete ${f.path}: $e', cfg.logLevel);
          }
        }
      }
    }
  }

  final endTime = DateTime.now();
  final duration = endTime.difference(startTime);
  final durationSeconds = duration.inMilliseconds / 1000.0;

  logInfo('[info] generation completed: $filesGenerated files generated in ${durationSeconds.toStringAsFixed(2)}s', cfg.logLevel);
  return changed;
}

Future<bool> _writeIfChanged(File file, String content, Config cfg) async {
  final old = await _read(file);
  final isChanged = old != content;
  if (isChanged) {
    await file.parent.create(recursive: true);
    await file.writeAsString(content, encoding: const SystemEncoding(), flush: true);
    logInfo('[write] ${file.path}', cfg.logLevel);
  }
  return isChanged;
}

Future<String> _read(File f) async {
  if (await f.exists()) {
    try {
      return await f.readAsString();
    } catch (_) {}
  }
  return '';
}

String _jsonFieldTemplate() => """// ignore_for_file: non_constant_identifier_names
// ignore_for_file: camel_case_types
// ignore_for_file: prefer_single_quotes

// This file is automatically generated. DO NOT EDIT, all your changes would be lost.

import 'package:meta/meta_meta.dart';

@Target({TargetKind.classType})
class JsonSerializable {
  const JsonSerializable();
}

@Target({TargetKind.field})
class JSONField {
  //Specify the parse field name
  final String? name;

  //Whether to participate in toJson
  final bool? serialize;
  
  //Whether to participate in fromMap
  final bool? deserialize;
  
  //Whether to participate in copyWith
  final bool? copyWith;
  
  //Enumeration or not
  final bool? isEnum;
  
  const JSONField({this.name, this.serialize, this.deserialize, this.isEnum, this.copyWith});
}
""";

String _renderEntity(Config cfg, EntitySource e, Map<String, String> classPathIndex) {
  final buf = StringBuffer();
  buf.writeln("import 'package:${cfg.packageName}/${cfg.genPath}/base/json_convert_content.dart';");
  buf.writeln("import 'package:${cfg.packageName}/${e.relativePathUnderLib}';");
  
  // Collect all imports and deduplicate
  final passthrough = _passthroughImports(cfg, e);
  final extraImportLines = _resolveImportLines(cfg, e, classPathIndex);
  
  // Merge and deduplicate using Set
  final allImports = <String>{...passthrough, ...extraImportLines};
  
  // Write all imports
  for (final line in allImports) {
    buf.writeln(line);
  }
  // Always add a blank line after imports
  buf.writeln('');
  
  for (final c in e.classes) {
    // $ClassFromJson
    buf.writeln("${c.name} \$${c.name}FromJson(Map<String, dynamic> json) {");
    buf.writeln("  final ${c.name} ${_lcFirst(c.name)} = ${c.name}();");
    for (final f in c.fields) {
      if (f.deserialize == false) continue;
      buf.writeln("  final ${_baseType(f)}? ${f.name} = ${_getterForField(f)};");
      buf.writeln("  if (${f.name} != null) {");
      buf.writeln("    ${_lcFirst(c.name)}.${f.name} = ${f.name};");
      buf.writeln("  }");
    }
    buf.writeln("  return ${_lcFirst(c.name)};");
    buf.writeln("}\n");

    // $ClassToJson
    buf.writeln("Map<String, dynamic> \$${c.name}ToJson(${c.name} entity) {");
    buf.writeln("  final Map<String, dynamic> data = <String, dynamic>{};");
    for (final f in c.fields) {
      if (f.serialize == false) continue;
      final key = f.jsonKeyName ?? f.name;
      if (f.isList) {
        final elem = f.elemType ?? 'dynamic';
        if (f.isEnum == true) {
          // For enum lists, elements are always non-nullable enums
          // Only the list itself can be nullable
          if (f.isNullable) {
            buf.writeln("  data['${key}'] = entity.${f.name}?.map((v) => v.name).toList();");
          } else {
            buf.writeln("  data['${key}'] = entity.${f.name}.map((v) => v.name).toList();");
          }
        } else if (elem == 'DateTime') {
          if (f.isNullable) {
            buf.writeln("  data['${key}'] = entity.${f.name}?.map((v) => v.toIso8601String()).toList();");
          } else {
            buf.writeln("  data['${key}'] = entity.${f.name}.map((v) => v.toIso8601String()).toList();");
          }
        } else if (_isPrimitive(elem)) {
          buf.writeln("  data['${key}'] = entity.${f.name};");
        } else {
          buf.writeln("  data['${key}'] = entity.${f.name}.map((v) => v.toJson()).toList();");
        }
      } else {
        final base = _baseType(f);
        if (f.isEnum == true) {
          buf.writeln("  data['${key}'] = entity.${f.name}?.name;");
        } else if (base == 'DateTime') {
          if (f.isNullable) {
            buf.writeln("  data['${key}'] = entity.${f.name}?.toIso8601String();");
          } else {
            buf.writeln("  data['${key}'] = entity.${f.name}.toIso8601String();");
          }
        } else if (_isPrimitive(base)) {
          buf.writeln("  data['${key}'] = entity.${f.name};");
        } else {
          // For non-primitive types (objects), use safe navigation if nullable
          if (f.isNullable) {
            buf.writeln("  data['${key}'] = entity.${f.name}?.toJson();");
          } else {
            buf.writeln("  data['${key}'] = entity.${f.name}.toJson();");
          }
        }
      }
    }
    buf.writeln("  return data;");
    buf.writeln("}\n");

    // extension copyWith - 只为有字段的类生成
    if (c.fields.isNotEmpty) {
      buf.writeln("extension ${c.name}Extension on ${c.name} {");
      buf.writeln("  ${c.name} copyWith({");
      for (final f in c.fields) {
        buf.writeln("    ${_baseType(f)}? ${f.name},");
      }
      buf.writeln("  }) {");
      buf.writeln("    return ${c.name}()\n" + c.fields.map((f) => "      ..${f.name} = ${f.name} ?? this.${f.name}").join("\n") + ";");
      buf.writeln("  }");
      buf.writeln("}");
    } else {
      // 空类只生成空的扩展
      buf.writeln("extension ${c.name}Extension on ${c.name} {");
      buf.writeln("}");
    }
  }
  return buf.toString();
}

String _getterForField(FieldInfo f) {
  if (f.isList) {
    final elem = f.elemType ?? 'dynamic';
    final key = f.jsonKeyName ?? f.name;
    if (f.isEnum == true) {
      return "(json['${key}'] as List<dynamic>?)?.map((e) => jsonConvert.convert<${elem}>(e, enumConvert: (v) => ${elem}.values.byName(v)) as ${elem}).toList()";
    }
    // Add line break for better readability (matching IDE plugin format)
    return "(json['${key}'] as List<dynamic>?)?.map(\n        (e) => jsonConvert.convert<${elem}>(e) as ${elem}).toList()";
  }
  final t = f.type.replaceAll('?', '');
  final key = f.jsonKeyName ?? f.name;
  if (f.isEnum == true) {
    return "jsonConvert.convert<${t}>(json['${key}'], enumConvert: (v) => ${t}.values.byName(v))";
  }
  return "jsonConvert.convert<${t}>(json['${key}'])";
}

String _lcFirst(String s) => s.isEmpty ? s : s[0].toLowerCase() + s.substring(1);

String _baseType(FieldInfo f) => f.type.replaceAll('?', '');

bool _isPrimitive(String t) {
  const primitives = {'int', 'double', 'num', 'bool', 'String', 'dynamic', 'Object', 'Map', 'List'};
  return primitives.contains(t) || t.startsWith('Map<') || t.startsWith('List<');
}

Map<String, String> _buildClassPathIndex(List<EntitySource> entities) {
  final map = <String, String>{};
  for (final e in entities) {
    for (final c in e.classes) {
      map[c.name] = e.relativePathUnderLib;
    }
  }
  return map;
}

Set<String> _resolveImportLines(Config cfg, EntitySource e, Map<String, String> classPathIndex) {
  final lines = <String>{};
  bool needMaterial = false;

  void addProjectType(String typeName) {
    final base = typeName.replaceAll('?', '');
    if (_isPrimitive(base)) return;
    final path = classPathIndex[base];
    if (path == null) return;
    if (path == e.relativePathUnderLib) return;
    lines.add("import 'package:${cfg.packageName}/$path';");
  }

  for (final c in e.classes) {
    for (final f in c.fields) {
      if (f.isList && f.elemType != null) {
        addProjectType(f.elemType!);
      } else {
        addProjectType(_baseType(f));
      }
      final bt = _baseType(f);
      if (bt == 'ValueNotifier' || bt.startsWith('ValueNotifier<')) {
        needMaterial = true;
      }
    }
  }
  if (needMaterial) {
    lines.add("import 'package:flutter/material.dart';");
  }
  return lines;
}

/// Filter and normalize passthrough imports from entity source file
List<String> _passthroughImports(Config cfg, EntitySource e) {
  final out = <String>{};
  for (final raw in e.imports) {
    final line = raw.trim();
    if (line.isEmpty) continue;
    // Skip self import of the entity file and generated base imports we add ourselves
    if (line.contains("${cfg.genPath}/base/json_convert_content.dart")) continue;
    if (line.contains(e.relativePathUnderLib)) continue;
    // Skip json_field.dart, any dart:convert, and any .g.dart imports
    if (line.endsWith("json_field.dart';")) continue;
    if (line.contains('dart:convert')) continue;
    if (line.endsWith(".g.dart';")) continue;
    out.add(line);
  }
  return out.toList();
}

String _renderConvertContent(Config cfg, List<EntitySource> entities) {
  final buf = StringBuffer();
  buf.writeln("// ignore_for_file: non_constant_identifier_names");
  buf.writeln("// ignore_for_file: camel_case_types");
  buf.writeln("// ignore_for_file: prefer_single_quotes");
  buf.writeln();
  buf.writeln("// This file is automatically generated. DO NOT EDIT, all your changes would be lost.");
  buf.writeln("import 'package:flutter/material.dart' show debugPrint;");
  for (final e in entities) {
    buf.writeln("import 'package:${cfg.packageName}/${e.relativePathUnderLib}';");
  }
  buf.writeln();
  buf.writeln('JsonConvert jsonConvert = JsonConvert();');
  buf.writeln();
  buf.writeln('typedef JsonConvertFunction<T> = T Function(Map<String, dynamic> json);');
  buf.writeln('typedef EnumConvertFunction<T> = T Function(String value);');
  buf.writeln('typedef ConvertExceptionHandler = void Function(Object error, StackTrace stackTrace);');
  buf.writeln('extension MapSafeExt<K, V> on Map<K, V> {');
  buf.writeln('  T? getOrNull<T>(K? key) {');
  buf.writeln('    if (!containsKey(key) || key == null) {');
  buf.writeln('      return null;');
  buf.writeln('    } else {');
  buf.writeln('      return this[key] as T?;');
  buf.writeln('    }');
  buf.writeln('  }');
  buf.writeln('}');
  buf.writeln();
  buf.writeln('class JsonConvert {');
  buf.writeln('\tstatic ConvertExceptionHandler? onError;');
  buf.writeln('\tJsonConvertClassCollection convertFuncMap = JsonConvertClassCollection();');
  buf.writeln();
  buf.writeln(
      '\t/// When you are in the development, to generate a new model class, hot-reload doesn\'t find new generation model class, you can build on MaterialApp method called jsonConvert. ReassembleConvertFuncMap (); This method only works in a development environment');
  buf.writeln('\t/// https://flutter.cn/docs/development/tools/hot-reload');
  buf.writeln('\t/// class MyApp extends StatelessWidget {');
  buf.writeln('\t///    const MyApp({Key? key})');
  buf.writeln('\t///        : super(key: key);');
  buf.writeln('\t///');
  buf.writeln('\t///    @override');
  buf.writeln('\t///    Widget build(BuildContext context) {');
  buf.writeln('\t///      jsonConvert.reassembleConvertFuncMap();');
  buf.writeln('\t///      return MaterialApp();');
  buf.writeln('\t///    }');
  buf.writeln('\t/// }');
  buf.writeln('\tvoid reassembleConvertFuncMap(){');
  buf.writeln('\t  bool isReleaseMode = const bool.fromEnvironment(\'dart.vm.product\');');
  buf.writeln('\t  if(!isReleaseMode) {');
  buf.writeln('\t    convertFuncMap = JsonConvertClassCollection();');
  buf.writeln('\t  }');
  buf.writeln('\t}');
  buf.writeln();
  buf.writeln('  T? convert<T>(dynamic value, {EnumConvertFunction? enumConvert}) {');
  buf.writeln('    if (value == null) {');
  buf.writeln('      return null;');
  buf.writeln('    }');
  buf.writeln('    if (value is T) {');
  buf.writeln('      return value;');
  buf.writeln('    }');
  buf.writeln('    try {');
  buf.writeln('      return _asT<T>(value, enumConvert: enumConvert);');
  buf.writeln('    } catch (e, stackTrace) {');
  buf.writeln('      debugPrint(\'asT<\$T> \$e \$stackTrace\');');
  buf.writeln('      if (onError != null) {');
  buf.writeln('        onError!(e, stackTrace);');
  buf.writeln('      }');
  buf.writeln('      return null;');
  buf.writeln('    }');
  buf.writeln('  }');
  buf.writeln();
  buf.writeln('  List<T?>? convertList<T>(List<dynamic>? value, {EnumConvertFunction? enumConvert}) {');
  buf.writeln('    if (value == null) {');
  buf.writeln('      return null;');
  buf.writeln('    }');
  buf.writeln('    try {');
  buf.writeln('      return value.map((dynamic e) => _asT<T>(e,enumConvert: enumConvert)).toList();');
  buf.writeln('    } catch (e, stackTrace) {');
  buf.writeln('      debugPrint(\'asT<\$T> \$e \$stackTrace\');');
  buf.writeln('      if (onError != null) {');
  buf.writeln('        onError!(e, stackTrace);');
  buf.writeln('      }');
  buf.writeln('      return <T>[];');
  buf.writeln('    }');
  buf.writeln('  }');
  buf.writeln();
  buf.writeln('List<T>? convertListNotNull<T>(dynamic value, {EnumConvertFunction? enumConvert}) {');
  buf.writeln('    if (value == null) {');
  buf.writeln('      return null;');
  buf.writeln('    }');
  buf.writeln('    try {');
  buf.writeln('      return (value as List<dynamic>).map((dynamic e) => _asT<T>(e,enumConvert: enumConvert)!).toList();');
  buf.writeln('    } catch (e, stackTrace) {');
  buf.writeln('      debugPrint(\'asT<\$T> \$e \$stackTrace\');');
  buf.writeln('      if (onError != null) {');
  buf.writeln('        onError!(e, stackTrace);');
  buf.writeln('      }');
  buf.writeln('      return <T>[];');
  buf.writeln('    }');
  buf.writeln('  }');
  buf.writeln();
  buf.writeln('  T? _asT<T extends Object?>(dynamic value,');
  buf.writeln('      {EnumConvertFunction? enumConvert}) {');
  buf.writeln('    final String type = T.toString();');
  buf.writeln('    final String valueS = value.toString();');
  buf.writeln('    if (enumConvert != null) {');
  buf.writeln('      return enumConvert(valueS) as T;');
  buf.writeln('    } else if (type == "String") {');
  buf.writeln('      return valueS as T;');
  buf.writeln('    } else if (type == "int") {');
  buf.writeln('      final int? intValue = int.tryParse(valueS);');
  buf.writeln('      if (intValue == null) {');
  buf.writeln('        return double.tryParse(valueS)?.toInt() as T?;');
  buf.writeln('      } else {');
  buf.writeln('        return intValue as T;');
  buf.writeln('      }');
  buf.writeln('    } else if (type == "double") {');
  buf.writeln('      return double.parse(valueS) as T;');
  buf.writeln('    } else if (type == "DateTime") {');
  buf.writeln('      return DateTime.parse(valueS) as T;');
  buf.writeln('    } else if (type == "bool") {');
  buf.writeln('      if (valueS == \'0\' || valueS == \'1\') {');
  buf.writeln('        return (valueS == \'1\') as T;');
  buf.writeln('      }');
  buf.writeln('      return (valueS == \'true\') as T;');
  buf.writeln('    } else if (type == "Map" || type.startsWith("Map<")) {');
  buf.writeln('      return value as T;');
  buf.writeln('    } else {');
  buf.writeln('      if (convertFuncMap.containsKey(type)) {');
  buf.writeln('        if (value == null) {');
  buf.writeln('          return null;');
  buf.writeln('        }');
  buf.writeln('        var covertFunc = convertFuncMap[type]!;');
  buf.writeln('        if(covertFunc is Map<String, dynamic>) {');
  buf.writeln('          return covertFunc(value as Map<String, dynamic>) as T;');
  buf.writeln('        }else{');
  buf.writeln('          return covertFunc(Map<String, dynamic>.from(value)) as T;');
  buf.writeln('        }');
  buf.writeln('      } else {');
  buf.writeln('        throw UnimplementedError(\'\$type unimplemented,you can try running the app again\');');
  buf.writeln('      }');
  buf.writeln('    }');
  buf.writeln('  }');
  buf.writeln();
  buf.writeln('\t//list is returned by type');
  buf.writeln('\tstatic M? _getListChildType<M>(List<Map<String, dynamic>> data) {');
  for (final e in entities) {
    for (final c in e.classes) {
      buf.writeln('\t\tif (<${c.name}>[] is M){');
      buf.writeln('\t\t\treturn data.map<${c.name}>((Map<String, dynamic> e) => ${c.name}.fromJson(e)).toList() as M;');
      buf.writeln('\t\t}');
    }
  }
  buf.writeln('\n\t\tdebugPrint("\$M not found");');
  buf.writeln('\t\treturn null;');
  buf.writeln('\t}');
  buf.writeln();
  buf.writeln('\tstatic M? fromJsonAsT<M>(dynamic json) {');
  buf.writeln('\t\tif (json is M) {');
  buf.writeln('\t\t\treturn json;');
  buf.writeln('\t\t}');
  buf.writeln('\t\tif (json is List) {');
  buf.writeln('\t\t\treturn _getListChildType<M>(json.map((dynamic e) => e as Map<String, dynamic>).toList());');
  buf.writeln('\t\t} else {');
  buf.writeln('\t\t\treturn jsonConvert.convert<M>(json);');
  buf.writeln('\t\t}');
  buf.writeln('\t}');
  buf.writeln();
  buf.writeln('}');
  buf.writeln();
  buf.writeln('class JsonConvertClassCollection {');
  buf.writeln('\tMap<String, JsonConvertFunction> convertFuncMap = {');
  for (final e in entities) {
    for (final c in e.classes) {
      buf.writeln('\t\t(${c.name}).toString(): ${c.name}.fromJson,');
    }
  }
  buf.writeln('\t};');
  buf.writeln();
  buf.writeln('  bool containsKey(String type) {');
  buf.writeln('    return convertFuncMap.containsKey(type);');
  buf.writeln('  }');
  buf.writeln();
  buf.writeln('  JsonConvertFunction? operator [](String key) {');
  buf.writeln('    return convertFuncMap[key];');
  buf.writeln('  }');
  buf.writeln('}');
  return buf.toString();
}
